{"version":3,"sources":["../src/index.js"],"names":["DataExtractor","get","data","keys","options","replace","trim","__process","then","output","params","initialPath","key","characters","currentPath","slice","outerLoop","i","length","current","__modifyOutput","path","splice","push","nested","substr","processed","isEmpty","fragments","isObject","final","value","undefined","onRead","results","includeUndefined","step","currentStepData","isArray","j"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport _ from \"lodash\";\nimport type { ExtractionOptions, ExtractedData, ExtractionParams } from \"./../types\";\n\n/**\n * Data extractor class.\n */\nclass DataExtractor {\n    /**\n     * Returns extracted data.\n     * @param data    Data object on which the extraction will be performed.\n     * @param keys    Comma-separated keys which need to be extracted. For nested keys, dot and square brackets notation is available.\n     * @param options    Extraction options.\n     * @returns {Promise<Object>}\n     */\n    async get(data: Object, keys: string = \"\", options: ExtractionOptions = {}): Object {\n        // First we remove all breaks from the string.\n        keys = keys.replace(/\\s/g, \"\").trim();\n\n        // Recursively processes all root and nested keys.\n        return this.__process({ data, keys }, options).then(({ output }) => output);\n    }\n\n    /**\n     * Processes given params with given extraction options. Can be called recursively on nested data.\n     * @param params     Contains data, keys, initial path and output object.\n     * @param options    Various options, eg. onRead callback or ability to still include keys with undefined values.\n     * @returns {Promise<ExtractedData>}\n     * @private\n     */\n    async __process(\n        params: ExtractionParams,\n        options: ExtractionOptions = {}\n    ): Promise<ExtractedData> {\n        const { data, keys = \"\", output = {}, initialPath = [] } = params;\n        let key: string = \"\",\n            characters: number = 0,\n            currentPath: Array<string> = initialPath.slice(0);\n        outerLoop: for (let i = 0; i <= keys.length; i++) {\n            const current = keys[i];\n            if (typeof current !== \"undefined\") {\n                characters++;\n            }\n            switch (true) {\n                case current === \",\":\n                case typeof current === \"undefined\": {\n                    key &&\n                        (await this.__modifyOutput(\n                            { output, key, data, path: currentPath },\n                            options\n                        ));\n                    key = \"\";\n                    currentPath = initialPath.slice(0);\n                    break;\n                }\n                case current === \"]\": {\n                    key &&\n                        (await this.__modifyOutput(\n                            { output, key, data, path: currentPath },\n                            options\n                        ));\n                    break outerLoop;\n                }\n                case current === \"[\": {\n                    const path = currentPath.splice(0);\n                    path.push(key);\n                    const nested: ExtractedData = await this.__process(\n                        {\n                            data,\n                            initialPath: path,\n                            keys: keys.substr(i + 1),\n                            output\n                        },\n                        options\n                    );\n                    characters += nested.processed.characters;\n                    i += nested.processed.characters;\n                    key = \"\";\n                    break;\n                }\n                case current === \".\":\n                    currentPath.push(key);\n                    key = \"\";\n                    break;\n                default:\n                    key += current;\n            }\n        }\n\n        return {\n            output,\n            processed: { characters }\n        };\n    }\n\n    /**\n     * Directly modifies final output object with extracted data. Can be called recursively on nested data.\n     * @param params\n     * @param options\n     * @returns {Promise<void>}\n     * @private\n     */\n    async __modifyOutput(\n        params: ExtractionParams = {},\n        options: ExtractionOptions = {}\n    ): Promise<void> {\n        const { output, data = {}, key = \"\", path = [] } = params;\n\n        if (_.isEmpty(key)) {\n            return;\n        }\n\n        const fragments: { output: Object, data: Object } = { output, data };\n\n        // If current data fragment is not an object or in other words, a value where we cannot do something like x[y],\n        // then we return immediately. For example if this was null, trying to do null[y] would throw an error.\n        if (!_.isObject(fragments.data)) {\n            return;\n        }\n\n        // Path is an array with keys that we need to go over. For example, company.image.src would have two\n        // items in path array: 'company' and 'image', so we must first read these.\n\n        // If we reached the last key (or if only one key was passed), then we just modify the output and exit.\n        if (path.length === 0) {\n            const final = { value: undefined, key };\n            if (typeof options.onRead === \"function\") {\n                const results = await options.onRead(data, key);\n                final.key = results[0];\n                final.value = results[1];\n            } else {\n                final.value = await data[key];\n            }\n\n            if (typeof final.value === \"undefined\") {\n                if (options.includeUndefined === true) {\n                    fragments.output[final.key] = final.value;\n                }\n            } else {\n                fragments.output[final.key] = final.value;\n            }\n\n            return;\n        }\n\n        // If we have keys that we need go over, let's take the first one.\n        for (let i = 0; i < path.length; i++) {\n            const step = path[i];\n\n            // If we don't have a key assigned in our output object, let's assign a default value to it.\n            // We read the value in received data, and if it's an array, that means we need to iterate and\n            // apply reading of received keys on each one.\n            const currentStepData = await fragments.data[step];\n            if (typeof fragments.output[step] === \"undefined\") {\n                switch (true) {\n                    case _.isArray(currentStepData):\n                        fragments.output[step] = [];\n                        break;\n                    case _.isObject(currentStepData):\n                        fragments.output[step] = {};\n                        break;\n                    default:\n                        fragments.output[step] = currentStepData;\n                }\n            }\n\n            // If value is an array, let's iterate over each and apply reading multiple times.\n            if (_.isArray(currentStepData)) {\n                for (let j = 0; j < currentStepData.length; j++) {\n                    if (typeof fragments.output[step][j] === \"undefined\") {\n                        fragments.output[step][j] = {};\n                    }\n\n                    await this.__modifyOutput(\n                        {\n                            output: fragments.output[step][j],\n                            path: path.slice(i + 1),\n                            key,\n                            data: currentStepData[j]\n                        },\n                        options\n                    );\n                }\n\n                break;\n            }\n\n            fragments.output = await fragments.output[step];\n            fragments.data = await fragments.data[step];\n\n            await this.__modifyOutput(\n                {\n                    output: fragments.output,\n                    data: fragments.data,\n                    path: path.slice(i + 1),\n                    key\n                },\n                options\n            );\n        }\n    }\n}\n\nexport default new DataExtractor();\n"]}