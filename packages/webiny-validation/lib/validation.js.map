{"version":3,"sources":["../src/validation.js"],"names":["entries","validators","invalidRules","Validation","constructor","__validators","setValidator","name","callable","getValidator","validate","value","options","isString","isEmpty","Error","parsedValidateProperty","__parseValidateProperty","params","validator","e","validationError","message","throw","validateSync","split","parsedValidators","forEach","v","trim","vName","shift"],"mappings":"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","file":"validation.js","sourcesContent":["// @flow\nimport _ from \"lodash\";\nimport ValidationError from \"./validationError\";\nimport type { Validator, ValidateOptions, ParsedValidators } from \"./../types\";\n\nconst entries = (validators: ParsedValidators): Array<[string, Array<string>]> => {\n    return (Object.entries(validators): any);\n};\n\nconst invalidRules = \"Validators must be specified as a string (eg. required,minLength:10,email).\";\n\n/**\n * Main class of Validation library.\n * Exported as a singleton instance, it offers methods for sync/async data validation and overwriting or adding new validators.\n *\n * @class Validation\n * @example\n * import { validation } from 'webiny-validation';\n *\n * // `validation` is a preconfigured instance of Validation class.\n * // From here you can either add new validators or use it as-is.\n */\nclass Validation {\n    /**\n     * Contains a list of all set validators.\n     * @private\n     */\n    __validators: { [string]: Validator };\n\n    constructor() {\n        this.__validators = {};\n    }\n\n    /**\n     * Add new validator.\n     * @param name Validator name.\n     * @param callable Validator function which throws a ValidationError if validation fails.\n     * @returns {Validation}\n     */\n    setValidator(name: string, callable: Validator): this {\n        this.__validators[name] = callable;\n        return this;\n    }\n\n    /**\n     * Get validator function by name.\n     * @param name Validator name.\n     * @returns {Validator} A validator function.\n     */\n    getValidator(name: string): Validator {\n        if (!this.__validators[name]) {\n            throw new ValidationError(\"Validator `\" + name + \"` does not exist!\", name);\n        }\n        return this.__validators[name];\n    }\n\n    /**\n     * Asynchronously validates value.\n     * @param value Value to validate.\n     * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n     * @param [options] Validation options.\n     * @returns {Promise<boolean | ValidationError>}\n     */\n    async validate(\n        value: any,\n        validators: string,\n        options: ValidateOptions = {}\n    ): Promise<boolean | ValidationError> {\n        if (_.isString(validators) && _.isEmpty(validators)) {\n            return true;\n        }\n\n        if (!_.isString(validators)) {\n            throw new Error(invalidRules);\n        }\n\n        const parsedValidateProperty = this.__parseValidateProperty(validators);\n\n        for (const [name, params] of entries(parsedValidateProperty)) {\n            const validator = this.getValidator(name);\n            try {\n                await validator(value, params);\n            } catch (e) {\n                const validationError = new ValidationError(e.message, name, value);\n                if (options.throw === false) {\n                    return validationError;\n                }\n                throw validationError;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Synchronously validates value.\n     * @param value Value to validate.\n     * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n     * @param [options] Validation options.\n     * @returns {Promise<boolean | ValidationError>}\n     */\n    validateSync(\n        value: any,\n        validators: string,\n        options: ValidateOptions = {}\n    ): boolean | ValidationError {\n        if (_.isString(validators) && _.isEmpty(validators)) {\n            return true;\n        }\n\n        if (!_.isString(validators)) {\n            throw new Error(invalidRules);\n        }\n\n        const parsedValidateProperty = this.__parseValidateProperty(validators);\n\n        for (const [name, params] of entries(parsedValidateProperty)) {\n            const validator = this.getValidator(name);\n            try {\n                validator(value, params);\n            } catch (e) {\n                const validationError = new ValidationError(e.message, name, value);\n                if (options.throw === false) {\n                    return validationError;\n                }\n                throw validationError;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Parses a string of validators with parameters.\n     * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n     * @returns {ParsedValidators}\n     * @private\n     */\n    __parseValidateProperty(validators: string): ParsedValidators {\n        let validate: Array<string> = validators.split(\",\");\n\n        const parsedValidators: ParsedValidators = {};\n        validate.forEach((v: string) => {\n            let params = _.trim(v).split(\":\");\n            let vName = params.shift();\n            parsedValidators[vName] = params;\n        });\n        return parsedValidators;\n    }\n}\n\nexport default Validation;\n"]}