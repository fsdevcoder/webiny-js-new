{"version":3,"sources":["../../src/router/generatePath.js"],"names":["patternCache","cacheLimit","cacheCount","compileGenerator","cacheKey","pattern","cache","compiledGenerator","compile","generatePath","params","generator","patternParams","query","paramKeys","Object","keys","map","name","p","stringify"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;;;AAGA,IAAMA,eAAe,EAArB;AACA,IAAMC,aAAa,KAAnB;AACA,IAAIC,aAAa,CAAjB;;AAEA,IAAMC,mBAAmB,SAAnBA,gBAAmB,UAAW;AAChC,QAAMC,WAAWC,OAAjB;AACA,QAAMC,QAAQN,aAAaI,QAAb,MAA2BJ,aAAaI,QAAb,IAAyB,EAApD,CAAd;;AAEA,QAAIE,MAAMD,OAAN,CAAJ,EAAoB,OAAOC,MAAMD,OAAN,CAAP;;AAEpB,QAAME,oBAAoB,uBAAaC,OAAb,CAAqBH,OAArB,CAA1B;;AAEA,QAAIH,aAAaD,UAAjB,EAA6B;AACzBK,cAAMD,OAAN,IAAiBE,iBAAjB;AACAL;AACH;;AAED,WAAOK,iBAAP;AACH,CAdD;;AAgBA;;;AAGA,IAAME,eAAe,SAAfA,YAAe,GAAgC;AAAA,QAA/BJ,OAA+B,uEAArB,GAAqB;AAAA,QAAhBK,MAAgB,uEAAP,EAAO;;AACjD,QAAIL,YAAY,GAAhB,EAAqB;AACjB,eAAOA,OAAP;AACH;AACD,QAAMM,YAAYR,iBAAiBE,OAAjB,CAAlB;;AAEA,QAAMO,gBAAgB,EAAtB;AACA,gCAAaP,OAAb,EAAsBO,aAAtB;;AAEA,QAAMC,QAAQ,EAAd;AACA,QAAMC,YAAYC,OAAOC,IAAP,CAAYN,MAAZ,CAAlB;AACAI,cAAUG,GAAV,CAAc,aAAK;AACf,YAAI,CAAC,oBAAOL,aAAP,EAAsB,EAAEM,MAAMC,CAAR,EAAtB,CAAL,EAAyC;AACrCN,kBAAMM,CAAN,IAAWT,OAAOS,CAAP,CAAX;AACH;AACJ,KAJD;;AAMA,WAAOR,UAAUD,MAAV,IAAoB,GAApB,GAA0B,sBAAGU,SAAH,CAAaP,KAAb,CAAjC;AACH,CAlBD;;kBAoBeJ,Y","file":"generatePath.js","sourcesContent":["import pathToRegexp from \"path-to-regexp\";\nimport qs from \"query-string\";\nimport _ from \"lodash\";\n\nconst patternCache = {};\nconst cacheLimit = 10000;\nlet cacheCount = 0;\n\nconst compileGenerator = pattern => {\n    const cacheKey = pattern;\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n    if (cache[pattern]) return cache[pattern];\n\n    const compiledGenerator = pathToRegexp.compile(pattern);\n\n    if (cacheCount < cacheLimit) {\n        cache[pattern] = compiledGenerator;\n        cacheCount++;\n    }\n\n    return compiledGenerator;\n};\n\n/**\n * Public API for generating a URL pathname from a pattern and parameters.\n */\nconst generatePath = (pattern = \"/\", params = {}) => {\n    if (pattern === \"/\") {\n        return pattern;\n    }\n    const generator = compileGenerator(pattern);\n\n    const patternParams = [];\n    pathToRegexp(pattern, patternParams);\n\n    const query = {};\n    const paramKeys = Object.keys(params);\n    paramKeys.map(p => {\n        if (!_.find(patternParams, { name: p })) {\n            query[p] = params[p];\n        }\n    });\n\n    return generator(params) + \"?\" + qs.stringify(query);\n};\n\nexport default generatePath;\n"]}