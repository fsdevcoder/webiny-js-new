{"version":3,"sources":["../src/memoryDriver.js"],"names":["MemoryDriver","constructor","data","save","entity","params","classId","isExisting","storedItemIndex","findIndex","id","toStorage","push","delete","index","splice","count","results","find","getResult","length","findOne","query","records","get","isEmpty","collection","forEach","key","value","Array","includes","record","flush","has","import","item","Error","importedItem"],"mappings":"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","file":"memoryDriver.js","sourcesContent":["// @flow\nimport { Driver, QueryResult } from \"webiny-entity\";\nimport _ from \"lodash\";\nimport mdbid from \"mdbid\";\nimport { Entity } from \"webiny-entity\";\nimport {\n    EntitySaveParams,\n    EntityFindParams,\n    EntityDeleteParams,\n    EntityFindOneParams\n} from \"webiny-entity/types\";\n\n/**\n * MemoryDriver is an implementation of in-memory entity driver.\n * Its main purpose is to run tests without the need to mock the driver.\n * Using this class you get the exact behavior of the entity storage as if using a real database, except it only exists as long as the process is running.\n */\nclass MemoryDriver extends Driver {\n    data: Object;\n\n    constructor() {\n        super();\n        this.data = {};\n    }\n\n    // eslint-disable-next-line\n    async save(entity: Entity, params: EntitySaveParams & {}): Promise<QueryResult> {\n        // Check if table exists.\n        if (!this.data[entity.classId]) {\n            this.data[entity.classId] = [];\n        }\n\n        if (entity.isExisting()) {\n            const storedItemIndex = _.findIndex(this.data[entity.classId], { id: entity.id });\n            this.data[entity.classId][storedItemIndex] = await entity.toStorage();\n            return new QueryResult(true);\n        }\n\n        entity.id = mdbid();\n        this.data[entity.classId].push(await entity.toStorage());\n        return new QueryResult(true);\n    }\n\n    // eslint-disable-next-line\n    async delete(entity: Entity, params: EntityDeleteParams & {}): Promise<QueryResult> {\n        if (!this.data[entity.classId]) {\n            return new QueryResult(true);\n        }\n\n        const index = _.findIndex(this.data[entity.classId], { id: entity.id });\n        if (index > -1) {\n            this.data[entity.classId].splice(index, 1);\n        }\n        return new QueryResult(true);\n    }\n\n    // eslint-disable-next-line\n    async count(entity: Entity, params: EntityFindParams): Promise<QueryResult> {\n        const results = await this.find(entity, params);\n        return new QueryResult(results.getResult().length);\n    }\n\n    async findOne(entity: Entity, params: EntityFindOneParams & {}): Promise<QueryResult> {\n        return new QueryResult(_.find(this.data[entity.classId], params.query));\n    }\n\n    // eslint-disable-next-line\n    async find(entity: Entity, params: EntityFindParams & Object): Promise<QueryResult> {\n        const records = this.data[entity.classId];\n        if (!records) {\n            return new QueryResult([]);\n        }\n\n        const query = _.get(params, \"query\", {});\n        if (_.isEmpty(query)) {\n            return new QueryResult(this.data[entity.classId]);\n        }\n\n        const collection = [];\n\n        this.data[entity.classId].forEach(record => {\n            for (const [key, value] of Object.entries(query)) {\n                if (value instanceof Array) {\n                    if (!value.includes(record[key])) {\n                        return true;\n                    }\n                } else if (record[key] !== value) {\n                    return true;\n                }\n            }\n            collection.push(record);\n        });\n\n        return new QueryResult(collection, { count: collection.length });\n    }\n\n    flush(classId: ?string) {\n        if (classId) {\n            _.has(this.data, classId) && delete this.data[classId];\n        } else {\n            this.data = {};\n        }\n        return this;\n    }\n\n    import(classId: string, data: Object) {\n        data.forEach((item, index) => {\n            if (!item.id) {\n                throw Error(\"Failed importing data - missing ID for item on index \" + index + \".\");\n            }\n        });\n\n        if (!this.data[classId]) {\n            this.data[classId] = [];\n        }\n\n        data.forEach(importedItem => {\n            const storedItemIndex = _.findIndex(this.data[classId], { id: importedItem.id });\n            if (storedItemIndex === -1) {\n                this.data[classId].push(importedItem);\n            } else {\n                this.data[classId][storedItemIndex] = importedItem;\n            }\n        });\n\n        return this;\n    }\n}\n\nexport default MemoryDriver;\n"]}