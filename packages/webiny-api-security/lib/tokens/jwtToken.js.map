{"version":3,"sources":["../../src/tokens/jwtToken.js"],"names":["JwtToken","constructor","config","data","identity","resolve","identityId","id","classId","encode","expiresOn","token","sign","exp","secret","decode","reject","verify","err","name","message","TOKEN_EXPIRED","TOKEN_INVALID"],"mappings":";;;;;;;;;;;;;;AACA;;;;AAGA;;;;;;AAOA,MAAMA,QAAN,CAAiC;;AAG7BC,gBAAYC,MAAZ,EAAoC;AAChC,aAAKA,MAAL,GAAcA,MAAd;AACH;;AAEDC,SAAKC,QAAL,EAA0C;AACtC,YAAI,OAAO,KAAKF,MAAL,CAAYC,IAAnB,KAA4B,UAAhC,EAA4C;AACxC,mBAAO,KAAKD,MAAL,CAAYC,IAAZ,CAAiBC,QAAjB,CAAP;AACH;;AAED;AACA,eAAO,kBAAQC,OAAR,CAAgB;AACnBC,wBAAYF,SAASG,EADF;AAEnBC,qBAASJ,SAASI;AAFC,SAAhB,CAAP;AAIH;;AAEKC,UAAN,CAAaL,QAAb,EAAiCM,SAAjC,EAAqE;AAAA;;AAAA;AACjE,kBAAMC,QAAQ,uBAAIC,IAAJ,CACV;AACIT,sBAAM,MAAM,MAAKA,IAAL,CAAUC,QAAV,CADhB;AAEIS,qBAAKH;AAFT,aADU,EAKV,MAAKR,MAAL,CAAYY,MALF,CAAd;;AAQA,mBAAO,kBAAQT,OAAR,CAAgBM,KAAhB,CAAP;AATiE;AAUpE;;AAEDI,WAAOJ,KAAP,EAAuC;AACnC,eAAO,sBAAY,CAACN,OAAD,EAAUW,MAAV,KAAqB;AACpC,mCAAIC,MAAJ,CAAWN,KAAX,EAAkB,KAAKT,MAAL,CAAYY,MAA9B,EAAsC,CAACI,GAAD,EAAMf,IAAN,KAAe;AACjD,oBAAIe,GAAJ,EAAS;AACL,wBAAIA,IAAIC,IAAJ,KAAa,mBAAjB,EAAsC;AAClCH,+BACI,kCAAwBE,IAAIE,OAA5B,EAAqC,8BAAoBC,aAAzD,CADJ;AAGH,qBAJD,MAIO;AACHL,+BACI,kCAAwBE,IAAIE,OAA5B,EAAqC,8BAAoBE,aAAzD,CADJ;AAGH;AACD;AACH;;AAEDjB,wBAAQF,IAAR;AACH,aAfD;AAgBH,SAjBM,CAAP;AAkBH;AAlD4B;;kBAqDlBH,Q","file":"jwtToken.js","sourcesContent":["// @flow\nimport jwt from \"jsonwebtoken\";\nimport type { Identity } from \"./../index\";\nimport type { IToken } from \"../../types\";\nimport AuthenticationError from \"../services/authenticationError\";\n\ntype JwtTokenConfig = {\n    secret: string,\n    data?: (identity: Identity) => Object\n};\n\nclass JwtToken implements IToken {\n    config: Object;\n\n    constructor(config: JwtTokenConfig) {\n        this.config = config;\n    }\n\n    data(identity: Identity): Promise<Object> {\n        if (typeof this.config.data === \"function\") {\n            return this.config.data(identity);\n        }\n\n        // Data to encode into a token\n        return Promise.resolve({\n            identityId: identity.id,\n            classId: identity.classId\n        });\n    }\n\n    async encode(identity: Identity, expiresOn: number): Promise<string> {\n        const token = jwt.sign(\n            {\n                data: await this.data(identity),\n                exp: expiresOn\n            },\n            this.config.secret\n        );\n\n        return Promise.resolve(token);\n    }\n\n    decode(token: string): Promise<Object> {\n        return new Promise((resolve, reject) => {\n            jwt.verify(token, this.config.secret, (err, data) => {\n                if (err) {\n                    if (err.name === \"TokenExpiredError\") {\n                        reject(\n                            new AuthenticationError(err.message, AuthenticationError.TOKEN_EXPIRED)\n                        );\n                    } else {\n                        reject(\n                            new AuthenticationError(err.message, AuthenticationError.TOKEN_INVALID)\n                        );\n                    }\n                    return;\n                }\n\n                resolve(data);\n            });\n        });\n    }\n}\n\nexport default JwtToken;\n"]}