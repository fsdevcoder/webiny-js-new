{"version":3,"sources":["../../../src/operators/logical/and.js"],"names":["and","canProcess","key","process","value","statement","output","isArray","forEach","object","andKey","andValue","isPlainObject","Error"],"mappings":";;;;;;;;;;AACA;;;;;;AAGA,MAAMA,MAAgB;AAClBC,gBAAY,CAAC,EAAEC,GAAF,EAAD,KAAa;AACrB,eAAOA,QAAQ,MAAf;AACH,KAHiB;AAIlBC,aAAS,CAAC,EAAEC,KAAF,EAASC,SAAT,EAAD,KAA0B;AAC/B,YAAIC,SAAS,EAAb;AACA,gBAAQ,IAAR;AACI,iBAAK,iBAAEC,OAAF,CAAUH,KAAV,CAAL;AACIA,sBAAMI,OAAN,CAAcC,UAAU;AACpB,yBAAK,MAAM,CAACC,MAAD,EAASC,QAAT,CAAX,IAAiC,uBAAeF,MAAf,CAAjC,EAAyD;AACrD,4BAAIH,WAAW,EAAf,EAAmB;AACfA,qCAASD,UAAUF,OAAV,CAAkB,EAAE,CAACO,MAAD,GAAUC,QAAZ,EAAlB,CAAT;AACH,yBAFD,MAEO;AACHL,sCAAU,UAAUD,UAAUF,OAAV,CAAkB,EAAE,CAACO,MAAD,GAAUC,QAAZ,EAAlB,CAApB;AACH;AACJ;AACJ,iBARD;AASA;AACJ,iBAAK,iBAAEC,aAAF,CAAgBR,KAAhB,CAAL;AACI,qBAAK,MAAM,CAACM,MAAD,EAASC,QAAT,CAAX,IAAiC,uBAAeP,KAAf,CAAjC,EAAwD;AACpD,wBAAIE,WAAW,EAAf,EAAmB;AACfA,iCAASD,UAAUF,OAAV,CAAkB,EAAE,CAACO,MAAD,GAAUC,QAAZ,EAAlB,CAAT;AACH,qBAFD,MAEO;AACHL,kCAAU,UAAUD,UAAUF,OAAV,CAAkB,EAAE,CAACO,MAAD,GAAUC,QAAZ,EAAlB,CAApB;AACH;AACJ;AACD;AACJ;AACI,sBAAME,MAAM,mDAAN,CAAN;AAtBR;;AAyBA,eAAO,MAAMP,MAAN,GAAe,GAAtB;AACH;AAhCiB,CAAtB;kBAmCeN,G","file":"and.js","sourcesContent":["// @flow\nimport _ from \"lodash\";\nimport type { Operator } from \"../../../types\";\n\nconst and: Operator = {\n    canProcess: ({ key }) => {\n        return key === \"$and\";\n    },\n    process: ({ value, statement }) => {\n        let output = \"\";\n        switch (true) {\n            case _.isArray(value):\n                value.forEach(object => {\n                    for (const [andKey, andValue] of Object.entries(object)) {\n                        if (output === \"\") {\n                            output = statement.process({ [andKey]: andValue });\n                        } else {\n                            output += \" AND \" + statement.process({ [andKey]: andValue });\n                        }\n                    }\n                });\n                break;\n            case _.isPlainObject(value):\n                for (const [andKey, andValue] of Object.entries(value)) {\n                    if (output === \"\") {\n                        output = statement.process({ [andKey]: andValue });\n                    } else {\n                        output += \" AND \" + statement.process({ [andKey]: andValue });\n                    }\n                }\n                break;\n            default:\n                throw Error(\"$and operator must receive an object or an array.\");\n        }\n\n        return \"(\" + output + \")\";\n    }\n};\n\nexport default and;\n"]}