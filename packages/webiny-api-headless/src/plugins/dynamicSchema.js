import pluralize from "pluralize";
import * as resolve from "webiny-api/graphql";
import { registerPlugins, getPlugins } from "webiny-plugins";
import createTypeName from "../utils/createTypeName";
import { resolveGet } from "../resolvers/resolveGet";
import { resolveList } from "../resolvers/resolveList";
import { resolveUpdate } from "../resolvers/resolveUpdate";

export default async config => {
    // Structure plugins for faster access
    const fieldTypePlugins = getPlugins("cms-headless-field-type").reduce((acc, pl) => {
        acc[pl.fieldType] = pl;
        return acc;
    }, {});

    // Load model data
    const db = config.database.mongodb;
    const models = await db
        .collection("CmsContentModel")
        .find({ deleted: { $ne: true } })
        .toArray();

    function renderFields(model, type) {
        return model.fields
            .map(f => {
                return fieldTypePlugins[f.type][type].createTypeField({ model, field: f });
            })
            .join("\n");
    }

    function renderInputFields(model) {
        return model.fields
            .map(f => {
                //const isRequired = Boolean(f.validation.find(v => v.id === "required"));
                return fieldTypePlugins[f.type].manage.createInputField({ model, field: f });
            })
            .join("\n");
    }

    function renderTypes(model, type) {
        return Object.values(fieldTypePlugins)
            .map(pl => {
                // Render gql types generated by field type plugins
                if (typeof pl[type].createTypes === "function") {
                    return pl[type].createTypes({ model, models });
                }
                return "";
            })
            .join("\n");
    }

    const plugins = [];

    models.forEach(model => {
        const typeName = createTypeName(model.modelId);

        // Create a schema plugin for each model (Management Schema)
        plugins.push({
            name: "graphql-schema-" + model.modelId + "-manage",
            type: "graphql-schema",
            schema: {
                stitching: {
                    linkTypeDefs: /* GraphQL */ `
                    ${renderTypes(model, "manage")}
                        
                    "${model.description}"
                    type Manage_${typeName} {
                        id: ID
                        createdBy: User
                        updatedBy: User
                        createdOn: DateTime
                        updatedOn: DateTime
                        ${renderFields(model, "manage")}
                    }
                    
                    input Manage_${typeName}Input {
                        ${renderInputFields(model)}
                    }
                    
                    type Manage_${typeName}Response {
                        data: Manage_${typeName}
                        error: Error
                    }
                    
                    type Manage_${typeName}ListResponse {
                        data: [Manage_${typeName}]
                        meta: ListMeta
                        error: Error
                    }
                    
                    extend type HeadlessManageQuery {
                        get${typeName}(id: ID, where: JSON, sort: String): Manage_${typeName}Response
                        
                        list${pluralize(typeName)}(
                            page: Int
                            perPage: Int
                            where: JSON
                            sort: JSON
                            search: SearchInput
                        ): Manage_${typeName}ListResponse
                    }
                    
                    extend type HeadlessManageMutation{
                        create${typeName}(data: Manage_${typeName}Input!): Manage_${typeName}Response
                        update${typeName}(id: ID!, data: Manage_${typeName}Input!): Manage_${typeName}Response
                        delete${typeName}(id: ID!): DeleteResponse
                    }
                `,
                    resolvers: {
                        CmsQuery: {
                            headlessManage: {
                                fragment: "... on CmsQuery { cms }",
                                resolve: resolve.dummyResolver
                            }
                        },
                        CmsMutation: {
                            headlessManage: {
                                fragment: "... on CmsMutation { cms }",
                                resolve: resolve.dummyResolver
                            }
                        },
                        HeadlessManageQuery: {
                            [`get${typeName}`]: resolveGet({ models, model }),
                            [`list${pluralize(typeName)}`]: resolveList({ models, model })
                        },
                        HeadlessManageMutation: {
                            [`create${typeName}`]: resolve.dummyResolver,
                            [`update${typeName}`]: resolveUpdate({ models, model }),
                            [`delete${typeName}`]: resolve.dummyResolver
                        },
                        [`Manage_${typeName}`]: model.fields.reduce(
                            (resolvers, field) => {
                                const { manage } = fieldTypePlugins[field.type];
                                let resolver = (entry, args, ctx, info) => entry[info.fieldName];
                                if (typeof manage.createResolver === "function") {
                                    resolver = manage.createResolver({ models, model, field });
                                }

                                resolvers[field.fieldId] = (entry, args, ctx, info) => {
                                    return resolver(entry, args, ctx, info);
                                };

                                return resolvers;
                            },
                            { id: entry => entry._id.toString() }
                        )
                    }
                }
            }
        });

        // Create a schema plugin for each model (Read-Only Schema)
        plugins.push({
            name: "graphql-schema-" + model.modelId + "-read",
            type: "graphql-schema",
            schema: {
                stitching: {
                    linkTypeDefs: /* GraphQL */ `
                    ${renderTypes(model, "read")}
                        
                    "${model.description}"
                    type ${typeName} {
                        id: ID
                        createdBy: User
                        updatedBy: User
                        createdOn: DateTime
                        updatedOn: DateTime
                        ${renderFields(model, "read")}
                    }
                    
                    type ${typeName}Response {
                        data: ${typeName}
                        error: Error
                    }
                    
                    type ${typeName}ListResponse {
                        data: [${typeName}]
                        meta: ListMeta
                        error: Error
                    }
                    
                    extend type HeadlessReadQuery {
                        get${typeName}(id: ID, where: JSON, sort: String): ${typeName}Response
                        
                        list${pluralize(typeName)}(
                            page: Int
                            perPage: Int
                            where: JSON
                            sort: JSON
                            search: SearchInput
                        ): ${typeName}ListResponse
                    }
                `,
                    resolvers: {
                        CmsQuery: {
                            headlessRead: {
                                fragment: "... on CmsQuery { cms }",
                                resolve: (parent, args, context) => {
                                    context.cms.headlessReadOnly = true;
                                    return {};
                                }
                            }
                        },
                        HeadlessReadQuery: {
                            [`get${typeName}`]: resolveGet({ model }),
                            [`list${pluralize(typeName)}`]: resolveList({ model })
                        },
                        [`${typeName}`]: model.fields.reduce(
                            (resolvers, field) => {
                                const { read } = fieldTypePlugins[field.type];
                                const resolver = read.createResolver({ models, model, field });

                                resolvers[field.fieldId] = (entry, args, ctx, info) => {
                                    if (ctx.cms.headlessReadOnly) {
                                        return resolver(entry, args, ctx, info);
                                    }

                                    return entry[info.fieldName];
                                };

                                return resolvers;
                            },
                            { id: entry => entry._id.toString() }
                        )
                    }
                }
            }
        });
    });

    registerPlugins(plugins);
};
