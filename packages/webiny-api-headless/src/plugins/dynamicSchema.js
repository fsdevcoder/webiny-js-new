import { upperFirst } from "lodash";
import pluralize from "pluralize";
import { Entity } from "webiny-entity";
import * as resolve from "webiny-api/graphql";
import { createEntityName, createTypeName } from "../utils";
import { registerPlugins, getPlugins } from "webiny-plugins";

export default async config => {
    // Structure plugins for faster access
    const fieldTypePlugins = getPlugins("cms-headless-field-type").reduce((acc, pl) => {
        acc[pl.fieldType] = pl;
        return acc;
    }, {});

    // Load model data
    const db = config.database.mongodb;
    const data = await db
        .collection("CmsContentModel")
        .find({ deleted: { $ne: true } })
        .toArray();

    function renderFields(model, type) {
        return model.fields
            .map(f => {
                return fieldTypePlugins[f.type][type].createTypeField({ model, field: f });
            })
            .join("\n");
    }

    function renderInputFields(model) {
        return model.fields
            .map(f => {
                //const isRequired = Boolean(f.validation.find(v => v.id === "required"));
                return fieldTypePlugins[f.type].manage.createInputField({ model, field: f });
            })
            .join("\n");
    }

    function renderTypes(model, type) {
        return Object.values(fieldTypePlugins)
            .map(pl => {
                // Render gql types generated by field type plugins
                if (typeof pl[type].createTypes === "function") {
                    return pl[type].createTypes({ model, models: data });
                }
                return "";
            })
            .join("\n");
    }

    const plugins = [];

    data.forEach(model => {
        const typeName = createTypeName(model.modelId);
        const entityName = createEntityName(model.modelId);

        const modelEntityFetcher = ctx => ctx.cms.entities[entityName];

        // Create entity plugin
        plugins.push({
            name: "entity-cms-" + model.modelId,
            type: "entity",
            namespace: "cms",
            entity: {
                name: entityName,
                factory: context => {
                    return class extends Entity {
                        static classId = "CmsContentEntry";

                        constructor() {
                            super();

                            const { user, security } = context;
                            const { User } = security.entities;
                            this.attr("modelId")
                                .char()
                                .setSkipOnPopulate()
                                .onSet(() => model.modelId)
                                .onGet(() => model.modelId)
                                .setDefaultValue(model.modelId);

                            this.attr("createdBy")
                                .entity(User)
                                .setSkipOnPopulate();

                            this.attr("updatedBy")
                                .entity(User)
                                .setSkipOnPopulate();

                            this.on("beforeCreate", async () => {
                                this.createdBy = user.id;
                            });

                            this.on("beforeUpdate", () => {
                                this.updatedBy = user.id;
                            });

                            model.fields.forEach(field => {
                                const fieldTypePlugin = fieldTypePlugins[field.type];

                                if (!fieldTypePlugin) {
                                    throw Error(
                                        `Missing plugin for headless field type "${field.type}"`
                                    );
                                }

                                // Create entity attribute
                                fieldTypePlugin.createAttribute({
                                    model,
                                    field,
                                    entity: this,
                                    context
                                });
                                const attribute = this.getAttribute(field.fieldId);
                                if (!attribute) {
                                    throw Error(
                                        `Field type plugin must create an attribute on the entity instance!\nCheck the "createAttribute" function in the "${
                                            fieldTypePlugin.name
                                        }" plugin!`
                                    );
                                }
                            });
                        }

                        static async findOne(params) {
                            params.query = params.query || {};
                            params.query.modelId = model.modelId;
                            return super.findOne(params);
                        }
                        static async find(params) {
                            params.query = params.query || {};
                            params.query.modelId = model.modelId;
                            return super.find(params);
                        }
                    };
                }
            }
        });

        // Create a schema plugin for each model (Management Schema)
        plugins.push({
            name: "graphql-schema-" + model.modelId + "-manage",
            type: "graphql-schema",
            schema: {
                stitching: {
                    linkTypeDefs: /* GraphQL */ `
                    ${renderTypes(model, "manage")}
                        
                    "${model.description}"
                    type Manage_${typeName} {
                        id: ID
                        createdBy: User
                        updatedBy: User
                        createdOn: DateTime
                        updatedOn: DateTime
                        ${renderFields(model, "manage")}
                    }
                    
                    input Manage_${typeName}Input {
                        ${renderInputFields(model)}
                    }
                    
                    type Manage_${typeName}Response {
                        data: Manage_${typeName}
                        error: Error
                    }
                    
                    type Manage_${typeName}ListResponse {
                        data: [${typeName}]
                        meta: ListMeta
                        error: Error
                    }
                    
                    extend type HeadlessManageQuery {
                        get${typeName}(id: ID, where: JSON, sort: String): Manage_${typeName}Response
                        
                        list${pluralize(typeName)}(
                            page: Int
                            perPage: Int
                            where: JSON
                            sort: JSON
                            search: SearchInput
                        ): Manage_${typeName}ListResponse
                    }
                    
                    extend type HeadlessManageMutation{
                        create${typeName}(data: Manage_${typeName}Input!): Manage_${typeName}Response
                        update${typeName}(id: ID!, data: Manage_${typeName}Input!): Manage_${typeName}Response
                        delete${typeName}(id: ID!): DeleteResponse
                    }
                `,
                    resolvers: {
                        CmsQuery: {
                            headlessManage: {
                                fragment: "... on CmsQuery { cms }",
                                resolve: resolve.dummyResolver
                            }
                        },
                        CmsMutation: {
                            headlessManage: {
                                fragment: "... on CmsMutation { cms }",
                                resolve: resolve.dummyResolver
                            }
                        },
                        HeadlessManageQuery: {
                            [`get${typeName}`]: resolve.resolveGet(modelEntityFetcher),
                            [`list${pluralize(typeName)}`]: resolve.resolveList(modelEntityFetcher)
                        },
                        HeadlessManageMutation: {
                            [`create${typeName}`]: resolve.resolveCreate(modelEntityFetcher),
                            [`update${typeName}`]: resolve.resolveUpdate(modelEntityFetcher),
                            [`delete${typeName}`]: resolve.resolveDelete(modelEntityFetcher)
                        }
                    }
                }
            }
        });

        // Create a schema plugin for each model (Read-Only Schema)
        plugins.push({
            name: "graphql-schema-" + model.modelId + "-read",
            type: "graphql-schema",
            schema: {
                stitching: {
                    linkTypeDefs: /* GraphQL */ `
                    ${renderTypes(model, "read")}
                        
                    "${model.description}"
                    type ${typeName} {
                        id: ID
                        createdBy: User
                        updatedBy: User
                        createdOn: DateTime
                        updatedOn: DateTime
                        ${renderFields(model, "read")}
                    }
                    
                    type ${typeName}Response {
                        data: ${typeName}
                        error: Error
                    }
                    
                    type ${typeName}ListResponse {
                        data: [${typeName}]
                        meta: ListMeta
                        error: Error
                    }
                    
                    extend type HeadlessReadQuery {
                        get${typeName}(id: ID, where: JSON, sort: String): ${typeName}Response
                        
                        list${pluralize(typeName)}(
                            page: Int
                            perPage: Int
                            where: JSON
                            sort: JSON
                            search: SearchInput
                        ): ${typeName}ListResponse
                    }
                `,
                    resolvers: {
                        CmsQuery: {
                            headlessRead: {
                                fragment: "... on CmsQuery { cms }",
                                resolve: (parent, args, context) => {
                                    context.cms.headlessReadOnly = true;
                                    return {};
                                }
                            }
                        },
                        HeadlessReadQuery: {
                            [`get${typeName}`]: resolve.resolveGet(modelEntityFetcher),
                            [`list${pluralize(typeName)}`]: resolve.resolveList(modelEntityFetcher)
                        },
                        [`${typeName}`]: model.fields.reduce((resolvers, field) => {
                            const { read } = fieldTypePlugins[field.type];
                            const resolver = read.createResolver({ model, field });

                            resolvers[field.fieldId] = (entity, args, ctx, info) => {
                                if (ctx.cms.headlessReadOnly) {
                                    return resolver(entity, args, ctx, info);
                                }

                                return entity[info.fieldName];
                            };

                            return resolvers;
                        }, {})
                    }
                }
            }
        });
    });

    registerPlugins(plugins);
};
