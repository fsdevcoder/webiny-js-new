{"version":3,"sources":["../../src/entityAttributes/entityAttribute.js"],"names":["EntityAttribute","constructor","name","attributesContainer","entity","options","async","classes","class","auto","save","enabled","delete","parentEntity","getParentModel","getParentEntity","on","getAutoSave","value","getCurrent","validation","getAutoDelete","deleteInitial","syncInitial","load","getInitial","getEntityClass","emit","events","getAttributeValueClass","setAutoSave","setAutoDelete","Array","isArray","classIdAttribute","getAttribute","classId","getValue","i","length","current","undefined","getClassIdAttribute","hasMultipleEntityClasses","canAcceptAnyEntityClass","setEntityClass","setValue","canSetValue","finalValue","onSetCallback","setCurrent","isClean","entityClass","id","get","isId","findById","Object","populate","getStorageValue","isLoading","setStorageValue","skipDifferenceCheck","setInitial","getJSONValue","toJSON","validate","isDirty","hasValidators","isLoaded","getValidationValue","valueValidation","isEmptyValue","INVALID_ATTRIBUTE","validateType","validateAttribute","validateValue","isValidInstance","expected","instance"],"mappings":"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","file":"entityAttribute.js","sourcesContent":["// @flow\n\nimport { Attribute } from \"webiny-model\";\nimport _ from \"lodash\";\nimport EntityAttributeValue from \"./entityAttributeValue\";\nimport type { EntityAttributesContainer } from \"./..\";\nimport EntityError from \"./../entityError\";\nimport type { EntityAttributeOptions } from \"./../../types\";\nimport { Entity } from \"..\";\nimport { ModelError } from \"webiny-model\";\n\ndeclare type EntityClass = Class<Entity> | Array<Class<Entity>>;\n\nclass EntityAttribute extends Attribute {\n    value: EntityAttributeValue;\n    classes: { entity: { class: Class<Entity> | Array<Class<Entity>> } };\n    auto: {\n        save: { enabled: boolean, options: ?Object },\n        delete: { enabled: boolean, options: ?Object }\n    };\n    options: EntityAttributeOptions;\n\n    constructor(\n        name: string,\n        attributesContainer: EntityAttributesContainer,\n        entity: EntityClass,\n        options: EntityAttributeOptions = {}\n    ) {\n        super(name, attributesContainer);\n\n        // This attribute is async because we need to load entities both on set and get calls.\n        this.async = true;\n\n        this.options = options;\n\n        this.classes = {\n            entity: { class: entity }\n        };\n\n        /**\n         * Auto save is always enabled, but delete not. This is because users will more often create many to one relationship than\n         * one to one. If user wants a strict one to one relationship, then delete flag must be set to true. In other words, it would\n         * be correct to say that if auto delete is enabled, we are dealing with one to one relationship.\n         * @type {{save: boolean, delete: boolean}}\n         */\n        this.auto = {\n            save: { enabled: true, options: null },\n            delete: { enabled: false, options: null }\n        };\n\n        /**\n         * Before save, let's validate and save linked entity.\n         *\n         * This ensures that parent entity has a valid ID which can be stored and also that all nested data is valid since\n         * validation will be called internally in the save method. Save operations will be executed starting from bottom\n         * nested entities, ending with the main parent entity.\n         */\n        const parentEntity = this.getParentModel().getParentEntity();\n        parentEntity.on(\"beforeSave\", async () => {\n            // At this point current value is an instance or is not instance. It cannot be in the 'loading' state, because that was\n            // already checked in the validate method - if in that step entity was in 'loading' state, it will be waited before proceeding.\n            if (this.getAutoSave()) {\n                // We don't need to validate here because validate method was called on the parent entity, which caused\n                // the validation of data to be executed recursively on all attribute values.\n                if (this.value.getCurrent() instanceof Entity) {\n                    await this.value.getCurrent().save({ validation: false });\n                }\n\n                // If initially we had a different entity linked, we must delete it.\n                // If initial is empty, that means nothing was ever loaded (attribute was not accessed) and there is nothing to do.\n                // Otherwise, deleteInitial method will internally delete only entities that are not needed anymore.\n                if (this.getAutoDelete()) {\n                    await this.value.deleteInitial(this.auto.delete.options);\n                }\n            }\n\n            // Set current entities as new initial values.\n            this.value.syncInitial();\n        });\n\n        /**\n         * Once parent entity starts the delete process, we must also make the same on all linked entities.\n         * The deletes are done on initial storage entities, not on entities stored as current value.\n         */\n        parentEntity.on(\"delete\", async () => {\n            if (this.getAutoDelete()) {\n                await this.value.load();\n                const entity = this.value.getInitial();\n                if (entity instanceof this.getEntityClass()) {\n                    await entity.emit(\"delete\");\n                }\n            }\n        });\n\n        parentEntity.on(\"beforeDelete\", async () => {\n            if (this.getAutoDelete()) {\n                await this.value.load();\n                const entity = this.value.getInitial();\n                if (entity instanceof this.getEntityClass()) {\n                    // We don't want to fire the \"delete\" event because its handlers were already executed by upper 'delete' listener.\n                    // That listener ensured that all callbacks that might've had blocked the deleted process were executed.\n                    await entity.delete({ validation: false, events: { delete: false } });\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns AttributeValue class to be used on construct.\n     * @returns {AttributeValue}\n     */\n    getAttributeValueClass() {\n        return EntityAttributeValue;\n    }\n\n    /**\n     * Should linked entity be automatically saved once parent entity is saved? By default, linked entities will be automatically saved,\n     * after main entity was saved. Can be disabled, although not recommended since manual saving needs to be done in that case.\n     * @param enabled\n     * @param options\n     * @returns {EntityAttribute}\n     */\n    setAutoSave(enabled: boolean = true, options: ?Object = null): EntityAttribute {\n        this.auto.save = { enabled, options };\n        return this;\n    }\n\n    /**\n     * Returns true if auto save is enabled, otherwise false.\n     * @returns {boolean}\n     */\n    getAutoSave(): boolean {\n        return this.auto.save.enabled;\n    }\n\n    /**\n     * Should linked entity be automatically deleted once parent entity is deleted? By default, linked entities will be automatically\n     * deleted, before main entity was deleted. Can be disabled, although not recommended since manual deletion needs to be done in that case.\n     * @param enabled\n     * @param options\n     * @returns {EntityAttribute}\n     */\n    setAutoDelete(enabled: boolean = true, options: ?Object = null): EntityAttribute {\n        this.auto.delete = { enabled, options };\n        return this;\n    }\n\n    /**\n     * Returns true if auto delete is enabled, otherwise false.\n     * @returns {boolean}\n     */\n    getAutoDelete(): boolean {\n        return this.auto.delete.enabled;\n    }\n\n    getEntityClass(): ?Class<Entity> {\n        if (Array.isArray(this.classes.entity.class)) {\n            let classIdAttribute = this.getParentModel().getAttribute(\n                this.options.classIdAttribute\n            );\n            if (classIdAttribute) {\n                const classId = classIdAttribute.getValue();\n                for (let i = 0; i < this.classes.entity.class.length; i++) {\n                    let current = this.classes.entity.class[i];\n                    if (current.classId === classId) {\n                        return current;\n                    }\n                }\n            }\n\n            return undefined;\n        }\n\n        return this.classes.entity.class;\n    }\n\n    getClassIdAttribute(): ?Attribute {\n        return this.getParentModel().getAttribute(this.options.classIdAttribute);\n    }\n\n    hasMultipleEntityClasses(): boolean {\n        return Array.isArray(this.classes.entity.class);\n    }\n\n    canAcceptAnyEntityClass(): boolean {\n        return this.hasMultipleEntityClasses() && this.classes.entity.class.length === 0;\n    }\n\n    setEntityClass(entity: Class<Entity>) {\n        this.classes.entity.class = entity;\n        return this;\n    }\n\n    setValue(value: mixed) {\n        if (!this.canSetValue()) {\n            return;\n        }\n\n        const finalValue = this.onSetCallback(value);\n        this.value.setCurrent(finalValue);\n\n        // If we are dealing with multiple Entity classes, we must assign received classId into\n        // attribute specified by the \"classIdAttribute\" option (passed on attribute construction).\n        const classIdAttribute = this.getClassIdAttribute();\n        if (classIdAttribute && this.hasMultipleEntityClasses()) {\n            if (finalValue instanceof Entity) {\n                return classIdAttribute.setValue(finalValue.classId);\n            }\n            if (!finalValue) {\n                return classIdAttribute.setValue(null);\n            }\n        }\n    }\n\n    /**\n     * Loads current entity if needed and returns it.\n     * @returns {Promise<void>}\n     */\n    async getValue(): Promise<mixed> {\n        if (this.value.isClean()) {\n            await this.value.load();\n        }\n\n        // \"Instance of Entity\" check is enough at this point.\n        if (this.value.getCurrent() instanceof Entity) {\n            return this.value.getCurrent();\n        }\n\n        const entityClass = this.getEntityClass();\n        if (!entityClass) {\n            return this.value.getCurrent();\n        }\n\n        const id = _.get(this.value.getCurrent(), \"id\", this.value.getCurrent());\n        if (\n            this.getParentModel()\n                .getParentEntity()\n                .isId(id)\n        ) {\n            const entity = await entityClass.findById(id);\n            if (entity) {\n                // If we initially had object with other data set, we must populate entity with it, otherwise\n                // just set loaded entity (because only an ID was received, without additional data).\n                if (this.value.getCurrent() instanceof Object) {\n                    entity.populate(this.value.getCurrent());\n                }\n                this.value.setCurrent(entity);\n            }\n            return this.value.getCurrent();\n        }\n\n        if (this.value.getCurrent() instanceof Object) {\n            const entity = new entityClass().populate(this.value.getCurrent());\n            this.value.setCurrent(entity);\n        }\n\n        // If valid value was not returned until this point, we return recently set value.\n        // The reason is, if the entity is about to be saved, validation must be executed and error must be thrown,\n        // warning users that passed value is invalid / entity was not found.\n        return this.value.getCurrent();\n    }\n\n    /**\n     * Returns storage value (entity ID or null).\n     * @returns {Promise<*>}\n     */\n    async getStorageValue() {\n        // Not using getValue method because it would load the entity without need.\n        let current = this.value.getCurrent();\n\n        // But still, if the value is loading currently, let's wait for it to load completely, and then use that value.\n        if (this.value.isLoading()) {\n            current = await this.value.load();\n        }\n\n        const id = _.get(current, \"id\", current);\n        return this.getParentModel()\n            .getParentEntity()\n            .isId(id)\n            ? id\n            : null;\n    }\n\n    /**\n     * Sets value received from storage.\n     * @param value\n     * @returns {EntityAttribute}\n     */\n    setStorageValue(value: mixed) {\n        this.value.setCurrent(value, { skipDifferenceCheck: true });\n        this.value.setInitial(value);\n        return this;\n    }\n\n    async getJSONValue() {\n        const value = await this.getValue();\n        if (value instanceof Entity) {\n            return await value.toJSON();\n        }\n        return value;\n    }\n\n    /**\n     * Validates on attribute level and then on entity level (its attributes recursively).\n     * If attribute has validators, we must unfortunately always load the attribute value. For example, if we had a 'required'\n     * validator, and entity not loaded, we cannot know if there is a value or not, and thus if the validator should fail.\n     * @returns {Promise<void>}\n     */\n    async validate() {\n        // If attribute is dirty, has validators or loading is in progress, wait until loaded.\n        if (this.value.isDirty() || this.hasValidators() || this.value.isLoading()) {\n            await this.value.load();\n        }\n\n        if (!this.value.isLoaded()) {\n            return;\n        }\n\n        const value = await this.getValidationValue();\n        const valueValidation = !Attribute.isEmptyValue(value);\n\n        if (valueValidation && this.hasMultipleEntityClasses()) {\n            if (!this.options.classIdAttribute) {\n                throw new ModelError(\n                    `Entity attribute \"${\n                        this.name\n                    }\" accepts multiple Entity classes but does not have \"classIdAttribute\" option defined.`,\n                    ModelError.INVALID_ATTRIBUTE\n                );\n            }\n\n            let classIdAttribute = this.getClassIdAttribute();\n            if (!classIdAttribute) {\n                throw new ModelError(\n                    `Entity attribute \"${\n                        this.name\n                    }\" accepts multiple Entity classes but classId attribute is missing.`,\n                    ModelError.INVALID_ATTRIBUTE\n                );\n            }\n\n            // We only do class validation if list of classes has been provided. Otherwise, we don't do the check.\n            // This is because in certain cases, a list of classes cannot be defined, and in other words, any\n            // class of entity can be assigned. One example is the File entity, which has an \"ref\" attribute, which\n            // can actually link to any type of entity.\n            if (!this.canAcceptAnyEntityClass()) {\n                if (!this.getEntityClass()) {\n                    throw new EntityError(\n                        `Entity attribute \"${\n                            this.name\n                        }\" accepts multiple Entity classes but it was not found (classId attribute holds value \"${classIdAttribute.getValue()}\").`,\n                        ModelError.INVALID_ATTRIBUTE\n                    );\n                }\n            }\n        }\n\n        valueValidation && (await this.validateType(value));\n        await this.validateAttribute(value);\n        valueValidation && (await this.validateValue(value));\n    }\n\n    /**\n     * Validates current value - if it's not a valid ID or an instance of Entity class, an error will be thrown.\n     */\n    async validateType(value: mixed) {\n        if (this.isValidInstance(value)) {\n            return;\n        }\n\n        this.expected(\"instance of Entity class\", typeof value);\n    }\n\n    async validateValue(value: mixed) {\n        // This validates on the entity level.\n        value instanceof Entity && (await value.validate());\n    }\n\n    isValidInstance(instance: ?Entity) {\n        if (this.hasMultipleEntityClasses()) {\n            return instance instanceof Entity;\n        }\n        return instance instanceof this.getEntityClass();\n    }\n}\n\nexport default EntityAttribute;\n"]}