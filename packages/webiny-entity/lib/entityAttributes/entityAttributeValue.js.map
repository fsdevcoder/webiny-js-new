{"version":3,"sources":["../../src/entityAttributes/entityAttributeValue.js"],"names":["EntityAttributeValue","constructor","attribute","queue","initial","load","isLoading","push","resolve","isLoaded","state","loading","getInitial","getParentModel","getParentEntity","isId","entity","getEntityClass","findById","setInitial","isClean","setCurrent","skipDifferenceCheck","loaded","__executeQueue","getCurrent","deleteInitial","options","hasInitial","get","delete","syncInitial","value","clean","isDifferentFrom","differentIds","current","Object","id","length","i"],"mappings":"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","file":"entityAttributeValue.js","sourcesContent":["// @flow\nimport { AttributeValue } from \"webiny-model\";\nimport type { Attribute } from \"webiny-model\";\nimport { Entity } from \"webiny-entity\";\nimport _ from \"lodash\";\n\nclass EntityAttributeValue extends AttributeValue {\n    queue: Array<Function>;\n    initial: ?mixed;\n\n    constructor(attribute: Attribute) {\n        super(attribute);\n        this.queue = [];\n\n        // Contains initial value received upon loading from storage. If the current value becomes different from initial,\n        // upon save, old entity must be removed. This is only active when auto delete option on the attribute is enabled,\n        // which then represents a one to one relationship.\n        this.initial = null;\n    }\n\n    /**\n     * Ensures data is loaded correctly, and in the end returns current value.\n     * @returns {Promise<*>}\n     */\n    async load() {\n        if (this.isLoading()) {\n            return new Promise(resolve => {\n                this.queue.push(resolve);\n            });\n        }\n\n        if (this.isLoaded()) {\n            return;\n        }\n\n        this.state.loading = true;\n\n        // Only if we have a valid ID set, we must load linked entity.\n        const initial = this.getInitial();\n        if (\n            this.attribute\n                .getParentModel()\n                .getParentEntity()\n                .isId(initial)\n        ) {\n            const entity = await this.attribute.getEntityClass().findById(initial);\n            this.setInitial(entity);\n            // If current value is not dirty, than we can set initial value as current, otherwise we\n            // assume that something else was set as current value like a new entity.\n            if (this.isClean()) {\n                this.setCurrent(entity, { skipDifferenceCheck: true });\n            }\n        }\n\n        this.state.loading = false;\n        this.state.loaded = true;\n\n        await this.__executeQueue();\n\n        return this.getCurrent();\n    }\n\n    async deleteInitial(options: ?{}) {\n        if (!this.hasInitial()) {\n            return;\n        }\n\n        // Initial value will always be an existing (already saved) Entity instance.\n        const initial = this.getInitial();\n        if (initial instanceof Entity && _.get(initial, \"id\") !== _.get(this.getCurrent(), \"id\")) {\n            await initial.delete(options);\n        }\n    }\n\n    syncInitial() {\n        this.setInitial(this.getCurrent());\n    }\n\n    setInitial(value: mixed) {\n        this.initial = value;\n        return this;\n    }\n\n    getInitial() {\n        return this.initial;\n    }\n\n    hasInitial() {\n        return this.initial instanceof this.attribute.getEntityClass();\n    }\n\n    /**\n     * Value cannot be set as clean if there is no ID present.\n     * @returns {EntityAttributeValue}\n     */\n    clean() {\n        if (_.get(this.getCurrent(), \"id\")) {\n            return super.clean();\n        }\n\n        return this;\n    }\n\n    isDifferentFrom(value: mixed): boolean {\n        const differentIds = _.get(this.current, \"id\", this.current) !== _.get(value, \"id\", value);\n        if (differentIds) {\n            return true;\n        }\n\n        // IDs are the same at this point.\n        if (value instanceof Object) {\n            if (value.id) {\n                return Object.keys(value).length > 1;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    async __executeQueue() {\n        if (this.queue.length) {\n            for (let i = 0; i < this.queue.length; i++) {\n                await this.queue[i]();\n            }\n            this.queue = [];\n        }\n    }\n}\n\nexport default EntityAttributeValue;\n"]}