{"version":3,"sources":["../src/model.js"],"names":["Model","constructor","params","attributes","validating","attributesContainer","createAttributesContainer","call","definition","Proxy","set","instance","key","value","attr","getAttribute","setValue","get","getValue","attribute","getAttributesContainer","has","setAttribute","name","getAttributes","clean","each","isDirty","isClean","populate","data","isObject","POPULATE_FAILED_NOT_OBJECT","getSkipOnPopulate","validate","invalidAttributes","all","map","e","code","message","INVALID_ATTRIBUTE","isEmpty","INVALID_ATTRIBUTES","toJSON","fields","onRead","received","__parseKeyParams","getJSONValue","arguments","path","defaultValue","steps","split","i","length","shift","lastStep","pop","model","toStorage","json","getToStorage","getStorageValue","populateFromStorage","setStorageValue"],"mappings":"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","file":"model.js","sourcesContent":["// @flow\nimport _ from \"lodash\";\nimport extractor from \"webiny-data-extractor\";\nimport DefaultAttributesContainer from \"./defaultAttributesContainer\";\nimport ModelError from \"./modelError\";\nimport type Attribute from \"./attribute\";\n\nclass Model {\n    attributes: { [string]: Attribute };\n    validating: boolean;\n    attributesContainer: DefaultAttributesContainer;\n\n    constructor(params?: Function) {\n        this.attributes = {};\n        this.validating = false;\n        this.attributesContainer = this.createAttributesContainer();\n\n        if (params) {\n            if (typeof params === \"function\") {\n                params.call(this);\n            } else if (typeof params === \"object\") {\n                // Here, params can be an object, which may contain several options.\n                if (typeof params.definition === \"function\") {\n                    params.definition.call(this);\n                }\n            }\n        }\n\n        return new Proxy((this: Object), {\n            set: (instance: Model, key: string, value: mixed) => {\n                const attr = instance.getAttribute(key);\n                if (attr) {\n                    attr.setValue(value);\n                    return true;\n                }\n\n                (instance: Object)[key] = value;\n                return true;\n            },\n            get: (instance: Model, key: string) => {\n                const attr = instance.getAttribute(key);\n                if (attr) {\n                    return attr.getValue();\n                }\n\n                return (instance: Object)[key];\n            }\n        });\n    }\n\n    attr(attribute: string): DefaultAttributesContainer {\n        return this.getAttributesContainer().attr(attribute);\n    }\n\n    createAttributesContainer(): DefaultAttributesContainer {\n        return new DefaultAttributesContainer(((this: any): Model));\n    }\n\n    getAttributesContainer(): DefaultAttributesContainer {\n        return this.attributesContainer;\n    }\n\n    getAttribute(attribute: string): ?Attribute {\n        if (_.has(this.attributes, attribute)) {\n            return this.attributes[attribute];\n        }\n    }\n\n    setAttribute(name: string, attribute: Attribute): Model {\n        this.attributes[name] = attribute;\n        return this;\n    }\n\n    getAttributes(): { [string]: Attribute } {\n        return this.attributes;\n    }\n\n    clean(): void {\n        _.each(this.attributes, (attribute: Attribute) => {\n            attribute.value.clean();\n        });\n    }\n\n    isDirty(): boolean {\n        let name;\n        for (name in this.attributes) {\n            const attribute: Attribute = this.attributes[name];\n            if (attribute.value.isDirty()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    isClean(): boolean {\n        return !this.isDirty();\n    }\n\n    /**\n     * Populates the model with given data.\n     */\n    populate(data: Object): this {\n        if (!_.isObject(data)) {\n            throw new ModelError(\n                \"Populate failed - received data not an object.\",\n                ModelError.POPULATE_FAILED_NOT_OBJECT\n            );\n        }\n\n        _.each(this.attributes, (attribute: Attribute, name: string) => {\n            if (attribute.getSkipOnPopulate()) {\n                return;\n            }\n\n            if (_.has(data, name)) {\n                attribute.setValue(data[name]);\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Validates values of all attributes.\n     */\n    async validate(): Promise<void> {\n        if (this.validating) {\n            return;\n        }\n        this.validating = true;\n\n        const invalidAttributes = {};\n        await Promise.all(\n            Object.keys(this.attributes).map(async (name: string) => {\n                const attribute: Attribute = this.attributes[name];\n                try {\n                    await attribute.validate();\n                } catch (e) {\n                    if (e instanceof ModelError) {\n                        invalidAttributes[name] = {\n                            code: e.code,\n                            data: e.data,\n                            message: e.message\n                        };\n                    } else {\n                        invalidAttributes[name] = {\n                            code: ModelError.INVALID_ATTRIBUTE,\n                            data: null,\n                            message: e.message\n                        };\n                    }\n                }\n            })\n        );\n\n        this.validating = false;\n\n        if (!_.isEmpty(invalidAttributes)) {\n            throw new ModelError(\"Validation failed.\", ModelError.INVALID_ATTRIBUTES, {\n                invalidAttributes\n            });\n        }\n    }\n\n    async toJSON(fields: string): Promise<Object> {\n        return await extractor.get(this, fields, {\n            onRead: async (data, key) => {\n                // Key can accept \":\" separated arguments, so we have to make sure those are parsed.\n                const received = this.__parseKeyParams(key);\n\n                if (typeof data.getAttribute === \"function\") {\n                    if (!data.getAttribute(received.key)) {\n                        return [received.key];\n                    }\n                    return [\n                        received.key,\n                        await data.getAttribute(received.key).getJSONValue(...received.arguments)\n                    ];\n                }\n                return [received.key, await data[received.key]];\n            }\n        });\n    }\n\n    async get(path: string | Array<string> = \"\", defaultValue: ?mixed): Promise<mixed> {\n        const steps = typeof path === \"string\" ? path.split(\".\") : path;\n        let value: Object = this;\n        for (let i = 0; i < steps.length; i++) {\n            if (!_.isObject(value)) {\n                return defaultValue;\n            }\n\n            // Key can accept \":\" separated arguments, so we have to make sure those are parsed.\n            const received = this.__parseKeyParams(steps[i]);\n\n            if (typeof value.getAttribute === \"function\") {\n                if (value.getAttribute(received.key)) {\n                    value = await value.getAttribute(received.key).getValue(...received.arguments);\n                } else {\n                    return defaultValue;\n                }\n            } else {\n                value = await value[steps[i]];\n            }\n        }\n        return value;\n    }\n\n    __parseKeyParams(key: string): { arguments: Array<string>, key: string } {\n        const received = { arguments: key.split(\":\"), key: \"\" };\n        received.key = received.arguments.shift();\n        return received;\n    }\n\n    async set(path: string, value: mixed): Promise<void> {\n        const steps = path.split(\".\");\n        const lastStep = steps.pop();\n\n        const model = await this.get(steps);\n        if (model && model.getAttribute) {\n            const attribute = model.getAttribute(lastStep);\n            if (attribute) {\n                return attribute.setValue(value);\n            }\n        }\n    }\n\n    /**\n     * Returns data that is suitable for latter saving in a storage layer (database, caching etc.). This is useful because attributes can\n     * have different values here (eg. only ID sometimes is needed) and also some attributes don't even need to be saved in the storage,\n     * which is most often the case with dynamic attributes.\n     */\n    async toStorage(): Promise<{}> {\n        const json = {};\n        for (let name in this.getAttributes()) {\n            const attribute = this.getAttribute(name);\n            // $FlowIgnore - we can be sure we have attribute because it's pulled from list of attributes, using getAttributes() method.\n            if (attribute.getToStorage()) {\n                // $FlowIgnore - we can be sure we have attribute because it's pulled from list of attributes, using getAttributes() method.\n                json[name] = await attribute.getStorageValue();\n            }\n        }\n\n        return json;\n    }\n\n    populateFromStorage(data: Object) {\n        if (!_.isObject(data)) {\n            throw new ModelError(\n                \"Populate failed - received data not an object.\",\n                ModelError.POPULATE_FAILED_NOT_OBJECT\n            );\n        }\n\n        let name;\n        for (name in this.getAttributes()) {\n            const attribute = this.getAttribute(name);\n            _.has(data, name) &&\n                // $FlowIgnore - we can be sure we have attribute because it's pulled from list of attributes, using getAttributes() method.\n                attribute.getToStorage() &&\n                // $FlowIgnore - we can be sure we have attribute because it's pulled from list of attributes, using getAttributes() method.\n                attribute.setStorageValue(data[name]);\n        }\n\n        return this;\n    }\n}\n\nexport default Model;\n"]}